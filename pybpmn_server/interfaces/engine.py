"""
Defines the interfaces and protocols for core components of a BPMN execution.

The module contains protocol definitions that standardize the expected
behavior of various components required for process execution, such as
token management, script evaluation, and BPMN instance handling. These
abstractions allow different implementations to integrate seamlessly
into the BPMN engine.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, List, Optional, Protocol, Union

from .data_objects import IInstanceData, IItemData

if TYPE_CHECKING:
    from .common import IAppDelegate
    from .elements import IDefinition, IElement, INode
    from .enums import NodeAction, TokenStatus
    from .server import IBPMNServer


class IScriptHandler(Protocol):
    def evaluate_expression(self, scope: Union[IItem, IToken], expression: Any) -> Any: ...
    def execute_script(self, scope: Union[IItem, IExecution], script: Any) -> Any: ...


class IToken(Protocol):
    id: Any
    type: Any
    execution: IExecution
    data_path: str
    start_node_id: Any
    parent_token: Optional[IToken]
    origin_item: Optional[IItem]
    path: List[IItem]
    loop: Any
    current_node: Any
    process_id: Any
    status: TokenStatus
    data: Any
    items_key: Any

    @property
    def current_item(self) -> Optional[IItem]: ...

    @property
    def last_item(self) -> Optional[IItem]: ...

    @property
    def first_item(self) -> Optional[IItem]: ...

    @property
    def children_tokens(self) -> List[IToken]: ...
    def save(self) -> Dict[str, Any]: ...
    def resume(self) -> None: ...
    def stop(self) -> None: ...
    def process_error(self, error_code: Any, calling_event: Any) -> Any: ...
    def process_escalation(self, escalation_code: Any, calling_event: Any) -> Any: ...
    def process_cancel(self, calling_event: Any) -> Any: ...
    def restored(self) -> None: ...
    def get_children_tokens(self) -> List[Any]: ...
    async def pre_execute(self) -> bool: ...
    async def pre_next(self) -> bool: ...
    async def execute(self, input_data: Any) -> Any: ...
    def append_data(self, input_data: Any, item: IItem) -> None: ...
    def terminate(self) -> None: ...
    async def signal(self, data: Any) -> Any: ...
    def get_full_path(self, full_path: Optional[Any] = None) -> List[IItem]: ...
    async def end(self) -> None: ...
    async def go_next(self) -> None: ...
    def get_sub_process_token(self) -> IToken: ...
    def log(self, *msg: Any) -> None: ...
    def info(self, *msg: Any) -> None: ...
    def error(self, msg: Any) -> None: ...


class IExecution(Protocol):
    instance: IInstanceData
    server: IBPMNServer
    tokens: Dict[Any, IToken]
    definition: IDefinition
    app_delegate: IAppDelegate
    process: Any
    promises: Any
    listener: Any
    is_locked: bool
    errors: Any
    item: Any
    message_matching_key: Any
    worker: Any
    user_name: Any
    id: Any
    status: Any
    action: NodeAction
    options: Any
    name: Any
    uids: Dict[str, Any]

    # From IServerComponent (to avoid circular dependency at runtime)
    # IServerComponent is a Protocol anyway, so we just include its fields
    cron: Any
    cache: Any
    engine: Any
    script_handler: IScriptHandler
    definitions: Any

    def get_node_by_id(self, id: Any) -> INode: ...
    def get_token(self, id: int) -> IToken: ...
    def get_items_data(self) -> List[IItemData]: ...
    async def save(self) -> None: ...
    async def end(self) -> None: ...
    def stop(self) -> None: ...
    def terminate(self) -> None: ...
    async def execute(
        self, start_node_id: Optional[Any] = None, input_data: Optional[Dict[str, Any]] = None
    ) -> None: ...
    async def signal_item(
        self, execution_id: Any, input_data: Any, options: Optional[Dict[str, Any]] = None
    ) -> IExecution: ...
    async def signal_event(
        self, execution_id: Any, input_data: Any, options: Optional[Dict[str, Any]] = None
    ) -> IExecution: ...
    async def signal_repeat_timer_event(
        self, execution_id: Any, prev_item: Any, input_data: Any, options: Optional[Dict[str, Any]] = None
    ) -> IExecution: ...
    def get_items(self, query: Optional[Any] = None) -> List[IItem]: ...
    def get_state(self) -> IInstanceData: ...
    def restored(self) -> None: ...
    def resume(self) -> None: ...
    def report(self) -> None: ...
    def get_new_id(self, scope: str) -> int: ...
    def get_uuid(self) -> Any: ...
    async def do_execution_event(self, process: Any, event: Any, event_details: Optional[Any] = None) -> Any: ...
    async def do_item_event(self, item: Any, event: Any, event_details: Optional[Any] = None) -> Any: ...
    def log(self, *msg: Any) -> None: ...
    def log_s(self, *msg: Any) -> None: ...
    def log_e(self, *msg: Any) -> None: ...
    def info(self, msg: Any) -> None: ...
    def error(self, msg: Any) -> None: ...
    def append_data(self, input_data: Any, item: IItem, data_path: Optional[Any] = None) -> None: ...
    def get_data(self, data_path: Any) -> Any: ...
    def process_queue(self) -> Any: ...


class IItem(IItemData):
    element: IElement
    token: IToken

    @property
    def context(self) -> IExecution: ...

    @property
    def node(self) -> INode: ...
