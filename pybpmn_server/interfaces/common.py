from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Protocol, Union

if TYPE_CHECKING:
    from .datastore import IDataStore, IModelsDatastore
    from .engine import IExecution, IItem, IScriptHandler
    from .server import ICacheManager


class IMongoDBDatabaseConfiguration(Protocol):
    MongoDB: Dict[str, str]


class ISQLiteDatabaseConfiguration(Protocol):
    SQLite: Dict[str, str]


class IConfiguration(Protocol):
    definitions_path: Optional[str]
    templates_path: Optional[str]
    timers: Mapping[str, int | float]
    database: Union[IMongoDBDatabaseConfiguration, ISQLiteDatabaseConfiguration, Any]
    api_key: str

    def definitions(self, server: Any) -> IModelsDatastore: ...
    def app_delegate(self, server: Any) -> IAppDelegate: ...
    def data_store(self, server: Any) -> IDataStore: ...
    def script_handler(self, server: Any) -> IScriptHandler: ...
    def cache_manager(self, server: Any) -> ICacheManager: ...


class ILogger(Protocol):
    def set_options(self, options: Dict[str, Any]) -> None: ...
    def clear(self) -> None: ...
    def get(self) -> List[Any]: ...
    def debug(self, *message: Any) -> Any: ...
    def warn(self, *message: Any) -> Any: ...
    def log(self, *message: Any) -> Any: ...
    def error(self, err: Any) -> None: ...
    def report_error(self, err: Any) -> None: ...
    async def save(self, filename: Any) -> None: ...
    async def save_for_instance(self, instance_id: str) -> Any: ...


class IServiceProvider(Protocol):
    # In Python, we can't easily express string indexer for different types in one Protocol
    # without using __getitem__ or similar, but for migration we use Any for indexer.
    def __getitem__(self, key: str) -> Union[Callable[..., Any], IServiceProvider]: ...


class IAppDelegate(Protocol):
    moddle_options: Any

    def get_services_provider(self, execution: IExecution) -> Union[IServiceProvider, Any]: ...  # Simplified Promise
    def send_email(self, to: Any, msg: Any, body: Any) -> Any: ...
    def execution_started(self, execution: IExecution) -> Any: ...
    def start_up(self, options: Any) -> Any: ...
    def message_thrown(self, message_id: str, data: Any, message_matching_key: Any, item: IItem) -> Any: ...
    def signal_thrown(self, signal_id: str, data: Any, message_matching_key: Any, item: IItem) -> Any: ...
    def issue_message(self, message_id: str, data: Any) -> Any: ...
    def issue_signal(self, message_id: str, data: Any) -> Any: ...
    def service_called(self, kwargs: Dict[str, Any], execution: IExecution, item: IItem) -> Any: ...
